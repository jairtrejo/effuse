#!/usr/bin/env ruby

require 'fileutils'
require 'optparse'
require 'ostruct'

opts = OpenStruct.new(dest_dir: Dir.home,
                      import:   false,
                      clean:    false,
                      confirm:  true,
                      backup:   true,
                      prefix:   '',
                      verbose:  false,
                      exclude:  %w[.effuseignore .git .gitignore .gitmodules
                                   *~ .*~ .*.swp])

if File.file?('.effuseignore')
  File.open('.effuseignore').each_line do |glob|
    opts.exclude << glob.chomp
  end
end

OptionParser.new do |o|
  o.banner = 'Usage: effuse [OPTIONS] [DEST]'

  o.on('-i', '--import', 'Import existing files') { opts.import = true }
  o.on('-c', '--clean', 'Remove symlinks') { opts.clean = true }

  o.separator ''

  o.on('--exclude GLOB', 'Exclude GLOB from symlinking') do |glob|
    opts.exclude << glob
  end
  o.on('--include GLOB', 'Include GLOB in symlinking') do |glob|
    opts.exclude.delete(glob)
  end

  o.separator ''

  o.on('-y', '--no-confirm', 'Do not ask before replacing files') do
    opts.confirm = false
  end
  o.on('-n', '--no-backup', 'Do not create backup files') do
    opts.backup = false
  end

  o.separator ''

  o.on('-p', '--prefix PREFIX', 'Prefix symlinked paths with PREFIX') do |prefix|
    opts.prefix = prefix
  end

  o.separator ''

  o.on('-v', '--verbose', 'Show verbose output') { opts.verbose = true }
  o.on_tail('-h', '--help', 'Show this message') do
    puts o
    exit
  end
end.parse!

opts.dest_dir = ARGV[0] if ARGV[0]

if File.identical?(opts.dest_dir, '.')
  puts 'error: destination directory is current directory'
  exit 1
end

$opts = opts # Don't hate me

def vputs(s)
  puts s if $opts.verbose
end

def confirm?(s)
  return true unless $opts.confirm
  loop do
    print "#{s} [Y/n] "
    input = $stdin.gets.chomp
    return true if input.empty? || input[0].downcase == ?y
    return false if input[0].downcase == ?n
  end
end

def backup(src)
  if $opts.backup
    dest = File.join(File.dirname(src), ".#{File.basename(src)}.effuse")
    vputs "renaming '#{src}' -> '#{dest}'"
    File.rename(src, dest)
  else
    vputs "deleting '#{src}'"
    File.delete(src)
  end
end

dirs = ['.']
files = {}

dirs.each do |dir|
  vputs "scanning '#{dir}'"
  Dir.foreach(dir) do |file|
    next if ['.', '..'].include?(file)

    if opts.exclude.any? {|glob| File.fnmatch(glob, file) }
      vputs "excluding '#{File.join(dir, file)}'"
      next
    end

    file = File.join(dir, file)

    if File.directory?(file)
      vputs "adding '#{file}'"
      dirs << file
      next
    end

    vputs "found '#{file}'"
    relpath = opts.prefix + File.join(file.split('/').drop(1))
    files[File.absolute_path(file)] = File.join(opts.dest_dir, relpath)
  end
end

if opts.clean
  files.each_pair do |src, dest|
    if File.exist?(dest) && File.identical?(src, dest)
      puts dest
      File.delete(dest)
    else
      vputs "not symlinked '#{dest}'"
    end
  end
else
  files.each_pair do |src, dest|
    if File.exist?(dest)
      if File.identical?(src, dest)
        vputs "already symlinked '#{dest}'"
        next
      elsif opts.import
        if confirm?("'#{dest}' already exists. Import it?")
          backup(src)
          vputs "renaming '#{dest}' -> '#{src}'"
          File.rename(dest, src)
        else
          vputs "skipping '#{dest}'"
          next
        end
      else # Replace destination file
        if confirm?("'#{dest}' already exists. Replace it?")
          backup(dest)
        else
          vputs "skipping '#{dest}'"
          next
        end
      end
    end

    puts "'#{dest}' -> '#{src}'"
    FileUtils.mkdir_p(File.dirname(dest))
    File.symlink(src, dest)
  end
end
